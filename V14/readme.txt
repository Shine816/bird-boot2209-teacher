传递中文问题

当我们在浏览器注册页面输入框中输入了中文，并以GET形式提交表单，那么浏览器会将表单信息拼接
到URL的抽象路径中。
http://localhost:8088/regUser?username=范传奇&password=123456&...

请求的请求行:
请求行:GET /regUser?username=范传奇&password=123456&... HTTP/1.1

HTTP协议规定请求与响应的前两部分都是文字，但是字符集必须为【ISO8859-1】.
而这是一个欧洲的字符集，里面不包含中文。因此如果以上述请求行样子传递中文则违背了HTTP协议
对于请求的要求，因此是不被允许的。
结论:中文不能被直接传递。


解决办法:
思路:用ISO8859-1支持的字符去表达不支持的字符。
ISO8859-1里，英文，数字，符号都是支持的字符。
a-z 0-9这些字符都可用。

中文"范"本身在ISO8859-1中不支持。
1:先将"范"用支持的字符集转换为2进制。例如用UTF-8编码转换为2进制。
  11101000 10001100 10000011
2:用ISO8859-1支持的字符中的两个字符:'1'和'0'来表达2进制
  用字符串:"111010001000110010000011" 来表达"范"的UTF-8编码里2进制样子
  /regUser?username=111010001000110010000011&password=xxxx&....

以上方式实现了传递中文的目的。但是缺点:用24个字符来表达1个中文字符，意味着数据量越大传送
速度越慢。

解决长度问题带来的传输效率低
思路:用16进制来表达2进制。因为16进制可以用字符0-9和A-F表达，这依然不违背ISO8859-1支持。

二进制         十进制         十六进制
0000            0               0
0001            1               1
0010            2               2
0011            3               3
0100            4               4
0101            5               5
0110            6               6
0111            7               7
1000            8               8
1001            9               9
1010            10              A
1011            11              B
1100            12              C
1101            13              D
1110            14              E
1111            15              F


中文"范"的UTF-8编码2进制:11101000 10001100 10000011
对应的16进制样子:        E8       8C       83
用字符串"E88C83"仍然可以表达中文的"范"且不违背ISO8859-1允许使用的字符
传递时:
/regUser?username=111010001000110010000011&password=xxxx&....
/regUser?username=E88C83&password=xxxx&....

长度问题解决了。新问题:如何与实际的英文数组组合区分?
例如:
一个人注册时，英文名就叫E88C83
/regUser?username=E88C83&password=xxxx&....
服务端读取到用户名:"E88C83"时将其还原为2进制后再以UTF-8转换为"范"还是这人就叫"E88C83"
为了解决此问题，URL格式要求如果想表达16进制信息时，每2位16进制前必须添加一个"%"
因此如果传递:
/regUser?username=E88C83&password=xxxx&....   此人名字就叫"E88C83"

如果传递:
/regUser?username=%E8%8C%83&password=xxxx&....
此时理解位用户名是3个字节的16进制形式，要先将E8 8C 83转换为:11101000 10001100 10000011
然后再将2进制以UTF-8还原为中文"范"

问题:如果我注册就叫"%E8%8C%8C".结论:不行！因为URL中:"%","?","="属于关键字，如果使用浏览
器会将输入的"%"转换为"%XX"表达


unicode中的中文"范"2进制为:10000011 00000011
UTF是Unicode Transformation Format的缩写，意为Unicode转换格式。

在网络上我们不是直接用unicode传输数据，而是用UTF传输。
原因:
在Socket层面传输范对应的字节:
客户端发送两个字节:10000011 00000011给服务端
当服务端读取到这两个字节时要将其还原为字符时会出现两种情况:
在unicode中每个英文占1字节，中文占2字节。
10000011 00000011 单独看可以理解为是两个英文字符(也可能是符号或数字)
10000011 00000011 将两个字节一起看就是中文"范"

为了解决服务端理解问题，因此我们会将unicode附带长度信息(目的就是让接收方理解几个字节表达一个字符)
UTF-8的规则
如果是单字节表达一个字符，那么直接用1字节即可。
2进制第一位一定的0
例如:
011011000
^
第一位时0，接收方会理解这就是单独1字节

如果时:

    vvvv   vvvvvv 数据位
11001100 10110010
^^^^
如果2进制第一位时1，那么接收方就要连续看前4为有几个连续的1表示要连续读几个字节表达内容
所以上述1100表达连续读取2字节。后面尾随的字节一定是以10开始在跟数据位
读取数来的字节:1100 110010


如果是中文:10000011 00000011 就要用3字节表达，其中用1个字节表达长度信息。

    vvvv   vvvvvv   vvvvvv   数据位
1110xxxx 10xxxxxx 10xxxxxx   x的部分就是原始unicode内容
^^^^
1110开始时接受方应当理解为要连续读取3个字节

举例:
"范"的标准unicode编码:10000011 00000011
11101000 10001100 10000011
E8       8C       83
